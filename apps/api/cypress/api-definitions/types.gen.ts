// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseURL: string;
};

export type CreateRepositoryDto = {
  /**
   * Repository owner
   */
  owner: string;
  /**
   * Repository name
   */
  repo: string;
  /**
   * HTTPS URL of the repository
   */
  url: string;
  /**
   * Git repository host provider
   */
  provider?: 'GITHUB';
  /**
   * GitHub personal access token (encrypted at rest, write-only)
   */
  token?: string;
};

export type GitRepositoryDto = {
  /**
   * Repository ID
   */
  id: string;
  /**
   * Repository owner (GitHub username or organization)
   */
  owner: string;
  /**
   * Repository name
   */
  repo: string;
  /**
   * HTTPS URL of the repository
   */
  url: string;
  /**
   * Git repository host provider
   */
  provider: 'GITHUB';
  /**
   * User ID who cloned the repository
   */
  createdBy: string;
  createdAt: string;
  updatedAt: string;
};

export type UpdateRepositoryDto = {
  /**
   * HTTPS URL of the repository
   */
  url?: string;
  /**
   * GitHub personal access token (encrypted at rest, write-only)
   */
  token?: string;
};

export type RepoIndexDto = {
  /**
   * Index ID
   */
  id: string;
  /**
   * Repository ID
   */
  repositoryId: string;
  /**
   * Repository URL
   */
  repoUrl: string;
  /**
   * Indexing status
   */
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  /**
   * Qdrant collection name
   */
  qdrantCollection: string;
  /**
   * Last indexed commit hash
   */
  lastIndexedCommit: string | null;
  /**
   * Embedding model used
   */
  embeddingModel: string | null;
  /**
   * Vector dimension size
   */
  vectorSize: number | null;
  /**
   * Chunking configuration hash
   */
  chunkingSignatureHash: string | null;
  /**
   * Estimated token count
   */
  estimatedTokens: number | null;
  /**
   * Actual indexed tokens
   */
  indexedTokens: number | null;
  /**
   * Error message if failed
   */
  errorMessage: string | null;
  createdAt: string;
  updatedAt: string;
};

export type TriggerReindexDto = {
  /**
   * Repository ID to reindex
   */
  repositoryId: string;
};

export type TriggerReindexResponseDto = {
  repoIndex: {
    /**
     * Index ID
     */
    id: string;
    /**
     * Repository ID
     */
    repositoryId: string;
    /**
     * Repository URL
     */
    repoUrl: string;
    /**
     * Indexing status
     */
    status: 'pending' | 'in_progress' | 'completed' | 'failed';
    /**
     * Qdrant collection name
     */
    qdrantCollection: string;
    /**
     * Last indexed commit hash
     */
    lastIndexedCommit: string | null;
    /**
     * Embedding model used
     */
    embeddingModel: string | null;
    /**
     * Vector dimension size
     */
    vectorSize: number | null;
    /**
     * Chunking configuration hash
     */
    chunkingSignatureHash: string | null;
    /**
     * Estimated token count
     */
    estimatedTokens: number | null;
    /**
     * Actual indexed tokens
     */
    indexedTokens: number | null;
    /**
     * Error message if failed
     */
    errorMessage: string | null;
    createdAt: string;
    updatedAt: string;
  };
  /**
   * Human-readable status message
   */
  message: string;
};

export type LiteLlmModelDto = {
  /**
   * Model identifier
   */
  id: string;
  /**
   * Owner of the model
   */
  ownedBy: string;
};

export type KnowledgeDocCreateDto = {
  /**
   * Knowledge document title
   */
  title: string;
  /**
   * Raw knowledge document content
   */
  content: string;
  /**
   * Optional LLM usage guidance for this document. If the politic instructs to fetch full content (e.g. "always fetch the full content instead of fetching only specific chunks"), full document retrieval is permitted.
   */
  politic?: string;
  /**
   * Optional tags to apply to the document
   */
  tags?: Array<string>;
};

export type KnowledgeDocDto = {
  id: string;
  publicId: number;
  content: string;
  title: string;
  summary?: string | null;
  politic?: string | null;
  embeddingModel?: string | null;
  tags: Array<string>;
  createdAt: string;
  updatedAt: string;
};

export type KnowledgeDocUpdateDto = {
  /**
   * Knowledge document title
   */
  title?: string;
  /**
   * Raw knowledge document content
   */
  content?: string;
  /**
   * Optional LLM usage guidance for this document. If the politic instructs to fetch full content (e.g. "always fetch the full content instead of fetching only specific chunks"), full document retrieval is permitted.
   */
  politic?: string;
  /**
   * Optional tags to apply to the document
   */
  tags?: Array<string>;
};

export type SuggestAgentInstructionsDto = {
  /**
   * User request describing how to adjust agent instructions
   */
  userRequest: string;
  /**
   * Optional thread id to continue a previous suggestion conversation
   */
  threadId?: string;
  /**
   * Optional LLM model to use for this suggestion
   */
  model?: string;
};

export type SuggestAgentInstructionsResponseDto = {
  /**
   * Updated agent instructions generated by the LLM
   */
  instructions: string;
  /**
   * Thread id used for this suggestion session
   */
  threadId: string;
};

export type SuggestGraphInstructionsDto = {
  /**
   * User request describing how to adjust agent instructions
   */
  userRequest: string;
  /**
   * Optional LLM model to use for this suggestion
   */
  model?: string;
};

export type SuggestGraphInstructionsResponseDto = {
  /**
   * Only agents with changed instructions are returned
   */
  updates: Array<{
    /**
     * Agent node id
     */
    nodeId: string;
    /**
     * Agent display name
     */
    name?: string;
    /**
     * Updated agent instructions generated by the LLM
     */
    instructions: string;
  }>;
};

export type ThreadAnalysisRequestDto = {
  /**
   * Optional user-provided input to guide the analysis
   */
  userInput?: string;
  /**
   * Optional LLM conversation id to continue the existing suggestion thread
   */
  threadId?: string;
  /**
   * Optional LLM model to use for this analysis
   */
  model?: string;
};

export type ThreadAnalysisResponseDto = {
  /**
   * LLM-generated analysis and improvement suggestions
   */
  analysis: string;
  /**
   * Identifier of the LLM conversation used for the analysis
   */
  conversationId: string;
};

export type KnowledgeContentSuggestionRequestDto = {
  /**
   * User request describing knowledge content to create or improve
   */
  userRequest: string;
  /**
   * Optional existing knowledge document title
   */
  currentTitle?: string;
  /**
   * Optional existing knowledge document content
   */
  currentContent?: string;
  /**
   * Optional existing tags for the knowledge document
   */
  currentTags?: Array<string>;
  /**
   * Optional thread id to continue a previous suggestion conversation
   */
  threadId?: string;
  /**
   * Optional LLM model to use for this suggestion
   */
  model?: string;
};

export type KnowledgeContentSuggestionResponseDto = {
  /**
   * Suggested knowledge document title
   */
  title: string;
  /**
   * Suggested knowledge document content
   */
  content: string;
  /**
   * Suggested tags for the knowledge document
   */
  tags?: Array<string>;
  /**
   * Thread id used for this suggestion session
   */
  threadId: string;
};

export type CreateGraphDto = {
  name: string;
  description?: string | null;
  schema: {
    nodes: Array<{
      /**
       * Unique identifier for this node
       */
      id: string;
      /**
       * Template id registered in TemplateRegistry
       */
      template: string;
      /**
       * Template-specific configuration
       */
      config: {
        [key: string]: unknown;
      };
    }>;
    edges?: Array<{
      /**
       * Source node ID
       */
      from: string;
      /**
       * Target node ID
       */
      to: string;
      /**
       * Optional edge label
       */
      label?: string;
    }>;
  };
  metadata?: {
    /**
     * Node coordinates and names by node ID
     */
    nodes?: Array<{
      id: string;
      /**
       * X coordinate of the node
       */
      x?: number;
      /**
       * Y coordinate of the node
       */
      y?: number;
      /**
       * Optional display name for the node
       */
      name?: string;
    }>;
    /**
     * Zoom level for graph display
     */
    zoom?: number;
    /**
     * X coordinate
     */
    x?: number;
    /**
     * Y coordinate
     */
    y?: number;
    [key: string]:
      | unknown
      | Array<{
          id: string;
          /**
           * X coordinate of the node
           */
          x?: number;
          /**
           * Y coordinate of the node
           */
          y?: number;
          /**
           * Optional display name for the node
           */
          name?: string;
        }>
      | number
      | undefined;
  } | null;
  /**
   * If true, graph will be deleted instead of restored after server restart
   */
  temporary?: boolean | null;
};

export type GraphDto = {
  id: string;
  name: string;
  description?: string | null;
  error?: string | null;
  version: string;
  /**
   * Target version after all queued revisions are applied
   */
  targetVersion: string;
  schema: {
    nodes: Array<{
      /**
       * Unique identifier for this node
       */
      id: string;
      /**
       * Template id registered in TemplateRegistry
       */
      template: string;
      /**
       * Template-specific configuration
       */
      config: {
        [key: string]: unknown;
      };
    }>;
    edges?: Array<{
      /**
       * Source node ID
       */
      from: string;
      /**
       * Target node ID
       */
      to: string;
      /**
       * Optional edge label
       */
      label?: string;
    }>;
  };
  status: 'created' | 'compiling' | 'running' | 'stopped' | 'error';
  metadata?: {
    /**
     * Node coordinates and names by node ID
     */
    nodes?: Array<{
      id: string;
      /**
       * X coordinate of the node
       */
      x?: number;
      /**
       * Y coordinate of the node
       */
      y?: number;
      /**
       * Optional display name for the node
       */
      name?: string;
    }>;
    /**
     * Zoom level for graph display
     */
    zoom?: number;
    /**
     * X coordinate
     */
    x?: number;
    /**
     * Y coordinate
     */
    y?: number;
    [key: string]:
      | unknown
      | Array<{
          id: string;
          /**
           * X coordinate of the node
           */
          x?: number;
          /**
           * Y coordinate of the node
           */
          y?: number;
          /**
           * Optional display name for the node
           */
          name?: string;
        }>
      | number
      | undefined;
  } | null;
  createdAt: string;
  updatedAt: string;
  /**
   * If true, graph will be deleted instead of restored after server restart
   */
  temporary?: boolean | null;
};

export type GraphNodeWithStatusDto = {
  /**
   * Node ID
   */
  id: string;
  /**
   * Display name for node
   */
  name: string;
  /**
   * Template identifier
   */
  template: string;
  /**
   * Node kind
   */
  type: 'runtime' | 'tool' | 'simpleAgent' | 'trigger' | 'resource' | 'mcp';
  /**
   * Current node status
   */
  status: 'stopped' | 'starting' | 'running' | 'idle';
  /**
   * Node configuration
   */
  config: unknown;
  /**
   * Last error message
   */
  error?: string | null;
  metadata?: {
    threadId?: string;
    runId?: string;
    parentThreadId?: string;
  };
  /**
   * Additional metadata exposed by the node implementation
   */
  additionalNodeMetadata?: {
    [key: string]: unknown;
  };
};

export type UpdateGraphDto = {
  name?: string;
  description?: string | null;
  schema?: {
    nodes: Array<{
      /**
       * Unique identifier for this node
       */
      id: string;
      /**
       * Template id registered in TemplateRegistry
       */
      template: string;
      /**
       * Template-specific configuration
       */
      config: {
        [key: string]: unknown;
      };
    }>;
    edges?: Array<{
      /**
       * Source node ID
       */
      from: string;
      /**
       * Target node ID
       */
      to: string;
      /**
       * Optional edge label
       */
      label?: string;
    }>;
  };
  metadata?: {
    /**
     * Node coordinates and names by node ID
     */
    nodes?: Array<{
      id: string;
      /**
       * X coordinate of the node
       */
      x?: number;
      /**
       * Y coordinate of the node
       */
      y?: number;
      /**
       * Optional display name for the node
       */
      name?: string;
    }>;
    /**
     * Zoom level for graph display
     */
    zoom?: number;
    /**
     * X coordinate
     */
    x?: number;
    /**
     * Y coordinate
     */
    y?: number;
    [key: string]:
      | unknown
      | Array<{
          id: string;
          /**
           * X coordinate of the node
           */
          x?: number;
          /**
           * Y coordinate of the node
           */
          y?: number;
          /**
           * Optional display name for the node
           */
          name?: string;
        }>
      | number
      | undefined;
  } | null;
  /**
   * If true, graph will be deleted instead of restored after server restart
   */
  temporary?: boolean | null;
  /**
   * Current version of the graph (for optimistic locking and 3-way merge base)
   */
  currentVersion: string;
};

export type UpdateGraphResponseDto = {
  /**
   * Updated graph
   */
  graph: {
    id: string;
    name: string;
    description?: string | null;
    error?: string | null;
    version: string;
    /**
     * Target version after all queued revisions are applied
     */
    targetVersion: string;
    schema: {
      nodes: Array<{
        /**
         * Unique identifier for this node
         */
        id: string;
        /**
         * Template id registered in TemplateRegistry
         */
        template: string;
        /**
         * Template-specific configuration
         */
        config: {
          [key: string]: unknown;
        };
      }>;
      edges?: Array<{
        /**
         * Source node ID
         */
        from: string;
        /**
         * Target node ID
         */
        to: string;
        /**
         * Optional edge label
         */
        label?: string;
      }>;
    };
    status: 'created' | 'compiling' | 'running' | 'stopped' | 'error';
    metadata?: {
      /**
       * Node coordinates and names by node ID
       */
      nodes?: Array<{
        id: string;
        /**
         * X coordinate of the node
         */
        x?: number;
        /**
         * Y coordinate of the node
         */
        y?: number;
        /**
         * Optional display name for the node
         */
        name?: string;
      }>;
      /**
       * Zoom level for graph display
       */
      zoom?: number;
      /**
       * X coordinate
       */
      x?: number;
      /**
       * Y coordinate
       */
      y?: number;
      [key: string]:
        | unknown
        | Array<{
            id: string;
            /**
             * X coordinate of the node
             */
            x?: number;
            /**
             * Y coordinate of the node
             */
            y?: number;
            /**
             * Optional display name for the node
             */
            name?: string;
          }>
        | number
        | undefined;
    } | null;
    createdAt: string;
    updatedAt: string;
    /**
     * If true, graph will be deleted instead of restored after server restart
     */
    temporary?: boolean | null;
  };
  /**
   * Created revision if update required applying non-metadata changes
   */
  revision?: {
    id: string;
    graphId: string;
    /**
     * Version the client changes were based on
     */
    baseVersion: string;
    /**
     * New head version after this revision
     */
    toVersion: string;
    /**
     * JSON Patch (RFC 6902) operations between old and new schemas
     */
    configDiff: Array<
      | {
          op: 'add';
          path: string;
          value: unknown;
        }
      | {
          op: 'remove';
          path: string;
        }
      | {
          op: 'replace';
          path: string;
          value: unknown;
        }
      | {
          op: 'move';
          from: string;
          path: string;
        }
      | {
          op: 'copy';
          from: string;
          path: string;
        }
      | {
          op: 'test';
          path: string;
          value: unknown;
        }
    >;
    /**
     * Config submitted by the client
     */
    clientConfig: {
      schema: {
        nodes: Array<{
          /**
           * Unique identifier for this node
           */
          id: string;
          /**
           * Template id registered in TemplateRegistry
           */
          template: string;
          /**
           * Template-specific configuration
           */
          config: {
            [key: string]: unknown;
          };
        }>;
        edges?: Array<{
          /**
           * Source node ID
           */
          from: string;
          /**
           * Target node ID
           */
          to: string;
          /**
           * Optional edge label
           */
          label?: string;
        }>;
      };
      name: string;
      description: string | null;
      temporary: boolean;
    };
    /**
     * Merged config result
     */
    newConfig: {
      schema: {
        nodes: Array<{
          /**
           * Unique identifier for this node
           */
          id: string;
          /**
           * Template id registered in TemplateRegistry
           */
          template: string;
          /**
           * Template-specific configuration
           */
          config: {
            [key: string]: unknown;
          };
        }>;
        edges?: Array<{
          /**
           * Source node ID
           */
          from: string;
          /**
           * Target node ID
           */
          to: string;
          /**
           * Optional edge label
           */
          label?: string;
        }>;
      };
      name: string;
      description: string | null;
      temporary: boolean;
    };
    status: 'pending' | 'applying' | 'applied' | 'failed';
    error?: string;
    createdAt: string;
    updatedAt: string;
  } | null;
};

export type ExecuteTriggerDto = {
  /**
   * Array of messages to send to the trigger
   */
  messages: Array<string>;
  /**
   * Optional thread sub-ID that will be used to create the full thread ID.
   */
  threadSubId?: string;
  /**
   * If true, do not wait for execution to finish (fire-and-forget).
   */
  async?: boolean;
};

export type ExecuteTriggerResponseDto = {
  /**
   * The thread ID used for this execution
   */
  externalThreadId: string;
  /**
   * The checkpoint namespace for this execution
   */
  checkpointNs?: string;
};

export type GraphRevisionDto = {
  id: string;
  graphId: string;
  /**
   * Version the client changes were based on
   */
  baseVersion: string;
  /**
   * New head version after this revision
   */
  toVersion: string;
  /**
   * JSON Patch (RFC 6902) operations between old and new schemas
   */
  configDiff: Array<
    | {
        op: 'add';
        path: string;
        value: unknown;
      }
    | {
        op: 'remove';
        path: string;
      }
    | {
        op: 'replace';
        path: string;
        value: unknown;
      }
    | {
        op: 'move';
        from: string;
        path: string;
      }
    | {
        op: 'copy';
        from: string;
        path: string;
      }
    | {
        op: 'test';
        path: string;
        value: unknown;
      }
  >;
  /**
   * Config submitted by the client
   */
  clientConfig: {
    schema: {
      nodes: Array<{
        /**
         * Unique identifier for this node
         */
        id: string;
        /**
         * Template id registered in TemplateRegistry
         */
        template: string;
        /**
         * Template-specific configuration
         */
        config: {
          [key: string]: unknown;
        };
      }>;
      edges?: Array<{
        /**
         * Source node ID
         */
        from: string;
        /**
         * Target node ID
         */
        to: string;
        /**
         * Optional edge label
         */
        label?: string;
      }>;
    };
    name: string;
    description: string | null;
    temporary: boolean;
  };
  /**
   * Merged config result
   */
  newConfig: {
    schema: {
      nodes: Array<{
        /**
         * Unique identifier for this node
         */
        id: string;
        /**
         * Template id registered in TemplateRegistry
         */
        template: string;
        /**
         * Template-specific configuration
         */
        config: {
          [key: string]: unknown;
        };
      }>;
      edges?: Array<{
        /**
         * Source node ID
         */
        from: string;
        /**
         * Target node ID
         */
        to: string;
        /**
         * Optional edge label
         */
        label?: string;
      }>;
    };
    name: string;
    description: string | null;
    temporary: boolean;
  };
  status: 'pending' | 'applying' | 'applied' | 'failed';
  error?: string;
  createdAt: string;
  updatedAt: string;
};

export type TemplateDto = {
  id: string;
  name: string;
  description: string;
  kind: 'runtime' | 'tool' | 'simpleAgent' | 'trigger' | 'resource' | 'mcp';
  schema: {
    [key: string]: unknown;
  };
  inputs?: Array<
    | {
        type: 'kind';
        value:
          | 'runtime'
          | 'tool'
          | 'simpleAgent'
          | 'trigger'
          | 'resource'
          | 'mcp';
        required?: boolean;
        multiple: boolean;
      }
    | {
        type: 'template';
        value: string;
        required?: boolean;
        multiple: boolean;
      }
  >;
  outputs?: Array<
    | {
        type: 'kind';
        value:
          | 'runtime'
          | 'tool'
          | 'simpleAgent'
          | 'trigger'
          | 'resource'
          | 'mcp';
        required?: boolean;
        multiple: boolean;
      }
    | {
        type: 'template';
        value: string;
        required?: boolean;
        multiple: boolean;
      }
  >;
};

export type ThreadDto = {
  /**
   * Thread ID
   */
  id: string;
  /**
   * Graph ID
   */
  graphId: string;
  /**
   * External thread ID from LangChain
   */
  externalThreadId: string;
  /**
   * Last LangGraph run_id observed for this thread
   */
  lastRunId?: string | null;
  createdAt: string;
  updatedAt: string;
  /**
   * Additional thread metadata
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * Source of thread creation (e.g., trigger template name)
   */
  source?: string | null;
  /**
   * Thread name (auto-generated from first user message)
   */
  name?: string | null;
  /**
   * Thread execution status
   */
  status: 'running' | 'done' | 'need_more_info' | 'stopped';
};

export type ThreadMessageDto = {
  id: string;
  threadId: string;
  nodeId: string;
  externalThreadId: string;
  createdAt: string;
  updatedAt: string;
  message:
    | {
        /**
         * Message role
         */
        role: 'human';
        /**
         * Message content
         */
        content: string;
        /**
         * Run ID associated with this message
         */
        runId?: string | null;
        /**
         * Additional message metadata
         */
        additionalKwargs?: {
          [key: string]: unknown;
        };
      }
    | {
        /**
         * Message role
         */
        role: 'ai';
        /**
         * Message content
         */
        content: string;
        /**
         * Message ID
         */
        id?: string;
        /**
         * Run ID associated with this message
         */
        runId?: string | null;
        /**
         * Original raw content as received from the provider
         */
        rawContent?: unknown;
        /**
         * Tool calls in the message
         */
        toolCalls?: Array<{
          /**
           * Tool name
           */
          name: string;
          /**
           * Tool arguments
           */
          args: {
            [key: string]: unknown;
          };
          /**
           * Tool call type
           */
          type: string;
          /**
           * Tool call ID
           */
          id: string;
          /**
           * Optional human-readable tool call title
           */
          title?: string;
        }>;
        /**
         * Additional message metadata
         */
        additionalKwargs?: {
          [key: string]: unknown;
        };
      }
    | {
        /**
         * Message ID
         */
        id?: string;
        /**
         * Message role
         */
        role: 'reasoning';
        /**
         * Reasoning trace emitted by the model
         */
        content: string;
        /**
         * Run ID associated with this message
         */
        runId?: string | null;
        /**
         * Additional message metadata
         */
        additionalKwargs?: {
          [key: string]: unknown;
        };
      }
    | {
        /**
         * Message role
         */
        role: 'system';
        /**
         * Message content
         */
        content: string;
        /**
         * Run ID associated with this message
         */
        runId?: string | null;
        /**
         * Additional message metadata
         */
        additionalKwargs?: {
          [key: string]: unknown;
        };
      }
    | {
        /**
         * Message role
         */
        role: 'tool';
        /**
         * Tool name
         */
        name: string;
        /**
         * Parsed tool result as JSON
         */
        content: {
          [key: string]: unknown;
        };
        /**
         * Tool call ID
         */
        toolCallId: string;
        /**
         * Run ID associated with this message
         */
        runId?: string | null;
        /**
         * Optional human-readable tool call title
         */
        title?: string;
        /**
         * Additional message metadata
         */
        additionalKwargs?: {
          [key: string]: unknown;
        };
      };
  /**
   * Full LLM request token usage & cost (entire request, not just this message)
   */
  requestTokenUsage?: {
    /**
     * Input tokens
     */
    inputTokens: number;
    /**
     * Cached input tokens
     */
    cachedInputTokens?: number;
    /**
     * Output tokens
     */
    outputTokens: number;
    /**
     * Reasoning tokens
     */
    reasoningTokens?: number;
    /**
     * Total tokens
     */
    totalTokens: number;
    /**
     * Total price in USD
     */
    totalPrice?: number;
    /**
     * Current context size in tokens (snapshot, not additive)
     */
    currentContext?: number;
  } | null;
};

export type ThreadUsageStatisticsDto = {
  /**
   * Total usage statistics for the entire thread
   */
  total: {
    /**
     * Input tokens
     */
    inputTokens: number;
    /**
     * Cached input tokens
     */
    cachedInputTokens?: number;
    /**
     * Output tokens
     */
    outputTokens: number;
    /**
     * Reasoning tokens
     */
    reasoningTokens?: number;
    /**
     * Total tokens
     */
    totalTokens: number;
    /**
     * Total price in USD
     */
    totalPrice?: number;
    /**
     * Current context size in tokens (snapshot, not additive)
     */
    currentContext?: number;
  };
  /**
   * Total number of requests (messages with requestTokenUsage)
   */
  requests: number;
  /**
   * Usage statistics breakdown by node ID
   */
  byNode: {
    [key: string]: {
      /**
       * Input tokens
       */
      inputTokens: number;
      /**
       * Cached input tokens
       */
      cachedInputTokens?: number;
      /**
       * Output tokens
       */
      outputTokens: number;
      /**
       * Reasoning tokens
       */
      reasoningTokens?: number;
      /**
       * Total tokens
       */
      totalTokens: number;
      /**
       * Total price in USD
       */
      totalPrice?: number;
      /**
       * Current context size in tokens (snapshot, not additive)
       */
      currentContext?: number;
    };
  };
  /**
   * Usage statistics breakdown by tool name
   */
  byTool: Array<{
    /**
     * Tool name
     */
    toolName: string;
    /**
     * Total tokens used by this tool
     */
    totalTokens: number;
    /**
     * Total price for this tool in USD
     */
    totalPrice?: number;
    /**
     * Number of times this tool was called
     */
    callCount: number;
  }>;
  /**
   * Aggregated statistics for all tool message requests
   */
  toolsAggregate: {
    /**
     * Input tokens
     */
    inputTokens: number;
    /**
     * Cached input tokens
     */
    cachedInputTokens?: number;
    /**
     * Output tokens
     */
    outputTokens: number;
    /**
     * Reasoning tokens
     */
    reasoningTokens?: number;
    /**
     * Total tokens
     */
    totalTokens: number;
    /**
     * Total price in USD
     */
    totalPrice?: number;
    /**
     * Current context size in tokens (snapshot, not additive)
     */
    currentContext?: number;
    /**
     * Number of requests (messages with requestTokenUsage)
     */
    requestCount: number;
  };
  /**
   * Aggregated statistics for all non-tool message requests (human, ai, system, reasoning)
   */
  messagesAggregate: {
    /**
     * Input tokens
     */
    inputTokens: number;
    /**
     * Cached input tokens
     */
    cachedInputTokens?: number;
    /**
     * Output tokens
     */
    outputTokens: number;
    /**
     * Reasoning tokens
     */
    reasoningTokens?: number;
    /**
     * Total tokens
     */
    totalTokens: number;
    /**
     * Total price in USD
     */
    totalPrice?: number;
    /**
     * Current context size in tokens (snapshot, not additive)
     */
    currentContext?: number;
    /**
     * Number of requests (messages with requestTokenUsage)
     */
    requestCount: number;
  };
};

export type GetRepositoriesData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by repository owner
     */
    owner?: string;
    /**
     * Filter by repository name
     */
    repo?: string;
    /**
     * Filter by host provider
     */
    provider?: 'GITHUB';
    /**
     * Maximum number of repositories to return
     */
    limit?: number;
    /**
     * Number of repositories to skip
     */
    offset?: number;
  };
  url: '/api/v1/git-repositories';
};

export type GetRepositoriesResponses = {
  200: Array<GitRepositoryDto>;
};

export type GetRepositoriesResponse =
  GetRepositoriesResponses[keyof GetRepositoriesResponses];

export type CreateRepositoryData = {
  body: CreateRepositoryDto;
  path?: never;
  query?: never;
  url: '/api/v1/git-repositories';
};

export type CreateRepositoryResponses = {
  201: GitRepositoryDto;
};

export type CreateRepositoryResponse =
  CreateRepositoryResponses[keyof CreateRepositoryResponses];

export type DeleteRepositoryData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/v1/git-repositories/{id}';
};

export type DeleteRepositoryResponses = {
  200: unknown;
};

export type GetRepositoryByIdData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/v1/git-repositories/{id}';
};

export type GetRepositoryByIdResponses = {
  200: GitRepositoryDto;
};

export type GetRepositoryByIdResponse =
  GetRepositoryByIdResponses[keyof GetRepositoryByIdResponses];

export type UpdateRepositoryData = {
  body: UpdateRepositoryDto;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/v1/git-repositories/{id}';
};

export type UpdateRepositoryResponses = {
  200: GitRepositoryDto;
};

export type UpdateRepositoryResponse =
  UpdateRepositoryResponses[keyof UpdateRepositoryResponses];

export type GetRepoIndexesData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by repository ID
     */
    repositoryId?: string;
    /**
     * Filter by status
     */
    status?: 'pending' | 'in_progress' | 'completed' | 'failed';
    /**
     * Maximum number of indexes to return
     */
    limit?: number;
    /**
     * Number of indexes to skip
     */
    offset?: number;
  };
  url: '/api/v1/git-repositories/indexes';
};

export type GetRepoIndexesResponses = {
  200: Array<RepoIndexDto>;
};

export type GetRepoIndexesResponse =
  GetRepoIndexesResponses[keyof GetRepoIndexesResponses];

export type GetRepoIndexByRepositoryIdData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/v1/git-repositories/{id}/index';
};

export type GetRepoIndexByRepositoryIdResponses = {
  200: {
    [key: string]: unknown;
  };
};

export type GetRepoIndexByRepositoryIdResponse =
  GetRepoIndexByRepositoryIdResponses[keyof GetRepoIndexByRepositoryIdResponses];

export type TriggerReindexData = {
  body: TriggerReindexDto;
  path?: never;
  query?: never;
  url: '/api/v1/git-repositories/reindex';
};

export type TriggerReindexResponses = {
  201: TriggerReindexResponseDto;
};

export type TriggerReindexResponse =
  TriggerReindexResponses[keyof TriggerReindexResponses];

export type ListModelsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/v1/litellm/models';
};

export type ListModelsResponses = {
  200: Array<LiteLlmModelDto>;
};

export type ListModelsResponse = ListModelsResponses[keyof ListModelsResponses];

export type ListDocsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by tags (match any)
     */
    tags?: Array<string>;
    /**
     * Search in title/summary/content
     */
    search?: string;
    limit?: number;
    offset?: number;
  };
  url: '/api/v1/knowledge-docs';
};

export type ListDocsResponses = {
  200: Array<KnowledgeDocDto>;
};

export type ListDocsResponse = ListDocsResponses[keyof ListDocsResponses];

export type CreateDocData = {
  body: KnowledgeDocCreateDto;
  path?: never;
  query?: never;
  url: '/api/v1/knowledge-docs';
};

export type CreateDocResponses = {
  201: KnowledgeDocDto;
};

export type CreateDocResponse = CreateDocResponses[keyof CreateDocResponses];

export type DeleteDocData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/v1/knowledge-docs/{id}';
};

export type DeleteDocResponses = {
  204: void;
};

export type DeleteDocResponse = DeleteDocResponses[keyof DeleteDocResponses];

export type GetDocData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/v1/knowledge-docs/{id}';
};

export type GetDocResponses = {
  200: KnowledgeDocDto;
};

export type GetDocResponse = GetDocResponses[keyof GetDocResponses];

export type UpdateDocData = {
  body: KnowledgeDocUpdateDto;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/v1/knowledge-docs/{id}';
};

export type UpdateDocResponses = {
  200: KnowledgeDocDto;
};

export type UpdateDocResponse = UpdateDocResponses[keyof UpdateDocResponses];

export type SuggestAgentInstructionsData = {
  body: SuggestAgentInstructionsDto;
  path: {
    graphId: string;
    nodeId: string;
  };
  query?: never;
  url: '/api/v1/graphs/{graphId}/nodes/{nodeId}/suggest-instructions';
};

export type SuggestAgentInstructionsResponses = {
  201: SuggestAgentInstructionsResponseDto;
};

export type SuggestAgentInstructionsResponse =
  SuggestAgentInstructionsResponses[keyof SuggestAgentInstructionsResponses];

export type SuggestGraphInstructionsData = {
  body: SuggestGraphInstructionsDto;
  path: {
    graphId: string;
  };
  query?: never;
  url: '/api/v1/graphs/{graphId}/suggest-instructions';
};

export type SuggestGraphInstructionsResponses = {
  201: SuggestGraphInstructionsResponseDto;
};

export type SuggestGraphInstructionsResponse =
  SuggestGraphInstructionsResponses[keyof SuggestGraphInstructionsResponses];

export type AnalyzeThreadData = {
  body: ThreadAnalysisRequestDto;
  path: {
    threadId: string;
  };
  query?: never;
  url: '/api/v1/threads/{threadId}/analyze';
};

export type AnalyzeThreadResponses = {
  201: ThreadAnalysisResponseDto;
};

export type AnalyzeThreadResponse =
  AnalyzeThreadResponses[keyof AnalyzeThreadResponses];

export type SuggestKnowledgeContentData = {
  body: KnowledgeContentSuggestionRequestDto;
  path?: never;
  query?: never;
  url: '/api/v1/knowledge-docs/suggest';
};

export type SuggestKnowledgeContentResponses = {
  201: KnowledgeContentSuggestionResponseDto;
};

export type SuggestKnowledgeContentResponse =
  SuggestKnowledgeContentResponses[keyof SuggestKnowledgeContentResponses];

export type GetAllGraphsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter graphs by IDs (comma-separated or repeated params)
     */
    ids?: Array<string>;
  };
  url: '/api/v1/graphs';
};

export type GetAllGraphsResponses = {
  200: Array<GraphDto>;
};

export type GetAllGraphsResponse =
  GetAllGraphsResponses[keyof GetAllGraphsResponses];

export type CreateGraphData = {
  body: CreateGraphDto;
  path?: never;
  query?: never;
  url: '/api/v1/graphs';
};

export type CreateGraphResponses = {
  201: GraphDto;
};

export type CreateGraphResponse =
  CreateGraphResponses[keyof CreateGraphResponses];

export type DeleteGraphData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/v1/graphs/{id}';
};

export type DeleteGraphResponses = {
  200: unknown;
};

export type FindGraphByIdData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/v1/graphs/{id}';
};

export type FindGraphByIdResponses = {
  200: GraphDto;
};

export type FindGraphByIdResponse =
  FindGraphByIdResponses[keyof FindGraphByIdResponses];

export type UpdateGraphData = {
  body: UpdateGraphDto;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/v1/graphs/{id}';
};

export type UpdateGraphResponses = {
  200: UpdateGraphResponseDto;
};

export type UpdateGraphResponse =
  UpdateGraphResponses[keyof UpdateGraphResponses];

export type GetCompiledNodesData = {
  body?: never;
  path: {
    id: string;
  };
  query?: {
    threadId?: string;
    runId?: string;
  };
  url: '/api/v1/graphs/{id}/nodes';
};

export type GetCompiledNodesResponses = {
  200: Array<GraphNodeWithStatusDto>;
};

export type GetCompiledNodesResponse =
  GetCompiledNodesResponses[keyof GetCompiledNodesResponses];

export type RunGraphData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/v1/graphs/{id}/run';
};

export type RunGraphResponses = {
  201: GraphDto;
};

export type RunGraphResponse = RunGraphResponses[keyof RunGraphResponses];

export type DestroyGraphData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: '/api/v1/graphs/{id}/destroy';
};

export type DestroyGraphResponses = {
  201: GraphDto;
};

export type DestroyGraphResponse =
  DestroyGraphResponses[keyof DestroyGraphResponses];

export type ExecuteTriggerData = {
  body: ExecuteTriggerDto;
  path: {
    graphId: string;
    triggerId: string;
  };
  query?: never;
  url: '/api/v1/graphs/{graphId}/triggers/{triggerId}/execute';
};

export type ExecuteTriggerResponses = {
  201: ExecuteTriggerResponseDto;
};

export type ExecuteTriggerResponse =
  ExecuteTriggerResponses[keyof ExecuteTriggerResponses];

export type GetGraphRevisionsData = {
  body?: never;
  path: {
    graphId: string;
  };
  query?: {
    status?: 'pending' | 'applying' | 'applied' | 'failed';
    /**
     * Maximum number of revisions to return
     */
    limit?: number;
  };
  url: '/api/v1/graphs/{graphId}/revisions';
};

export type GetGraphRevisionsResponses = {
  200: Array<GraphRevisionDto>;
};

export type GetGraphRevisionsResponse =
  GetGraphRevisionsResponses[keyof GetGraphRevisionsResponses];

export type GetGraphRevisionData = {
  body?: never;
  path: {
    graphId: string;
    id: string;
  };
  query?: never;
  url: '/api/v1/graphs/{graphId}/revisions/{id}';
};

export type GetGraphRevisionResponses = {
  200: GraphRevisionDto;
};

export type GetGraphRevisionResponse =
  GetGraphRevisionResponses[keyof GetGraphRevisionResponses];

export type GetAllTemplatesData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/v1/templates';
};

export type GetAllTemplatesResponses = {
  200: Array<TemplateDto>;
};

export type GetAllTemplatesResponse =
  GetAllTemplatesResponses[keyof GetAllTemplatesResponses];

export type GetThreadsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by graph ID
     */
    graphId?: string;
    /**
     * Filter by thread statuses
     */
    statuses?: Array<'running' | 'done' | 'need_more_info' | 'stopped'>;
    /**
     * Maximum number of threads to return
     */
    limit?: number;
    /**
     * Number of threads to skip
     */
    offset?: number;
  };
  url: '/api/v1/threads';
};

export type GetThreadsResponses = {
  200: Array<ThreadDto>;
};

export type GetThreadsResponse = GetThreadsResponses[keyof GetThreadsResponses];

export type DeleteThreadData = {
  body?: never;
  path: {
    threadId: string;
  };
  query?: never;
  url: '/api/v1/threads/{threadId}';
};

export type DeleteThreadResponses = {
  200: unknown;
};

export type GetThreadByIdData = {
  body?: never;
  path: {
    threadId: string;
  };
  query?: never;
  url: '/api/v1/threads/{threadId}';
};

export type GetThreadByIdResponses = {
  200: ThreadDto;
};

export type GetThreadByIdResponse =
  GetThreadByIdResponses[keyof GetThreadByIdResponses];

export type GetThreadByExternalIdData = {
  body?: never;
  path: {
    externalThreadId: string;
  };
  query?: never;
  url: '/api/v1/threads/external/{externalThreadId}';
};

export type GetThreadByExternalIdResponses = {
  200: ThreadDto;
};

export type GetThreadByExternalIdResponse =
  GetThreadByExternalIdResponses[keyof GetThreadByExternalIdResponses];

export type GetThreadMessagesData = {
  body?: never;
  path: {
    threadId: string;
  };
  query?: {
    /**
     * Filter messages by node ID (agent node)
     */
    nodeId?: string;
    /**
     * Maximum number of messages to return
     */
    limit?: number;
    /**
     * Number of messages to skip
     */
    offset?: number;
  };
  url: '/api/v1/threads/{threadId}/messages';
};

export type GetThreadMessagesResponses = {
  200: Array<ThreadMessageDto>;
};

export type GetThreadMessagesResponse =
  GetThreadMessagesResponses[keyof GetThreadMessagesResponses];

export type GetThreadUsageStatisticsData = {
  body?: never;
  path: {
    threadId: string;
  };
  query?: never;
  url: '/api/v1/threads/{threadId}/usage-statistics';
};

export type GetThreadUsageStatisticsResponses = {
  200: ThreadUsageStatisticsDto;
};

export type GetThreadUsageStatisticsResponse =
  GetThreadUsageStatisticsResponses[keyof GetThreadUsageStatisticsResponses];

export type StopThreadData = {
  body?: never;
  path: {
    threadId: string;
  };
  query?: never;
  url: '/api/v1/threads/{threadId}/stop';
};

export type StopThreadResponses = {
  201: ThreadDto;
};

export type StopThreadResponse = StopThreadResponses[keyof StopThreadResponses];

export type StopThreadByExternalIdData = {
  body?: never;
  path: {
    externalThreadId: string;
  };
  query?: never;
  url: '/api/v1/threads/external/{externalThreadId}/stop';
};

export type StopThreadByExternalIdResponses = {
  201: ThreadDto;
};

export type StopThreadByExternalIdResponse =
  StopThreadByExternalIdResponses[keyof StopThreadByExternalIdResponses];
