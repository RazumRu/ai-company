import { basename } from 'node:path';

import { ToolRunnableConfig } from '@langchain/core/tools';
import { Injectable } from '@nestjs/common';
import dedent from 'dedent';
import { isObject } from 'lodash';
import { z } from 'zod';

import { BaseAgentConfigurable } from '../../../../agents/services/nodes/base-node';
import { zodToAjvSchema } from '../../../agent-tools.utils';
import {
  ExtendedLangGraphRunnableConfig,
  ToolInvokeResult,
} from '../../base-tool';
import { FilesBaseTool, FilesBaseToolConfig } from './files-base.tool';

const MAX_MATCHES = 15;

export const FilesSearchTextToolSchema = z.object({
  searchInDirectory: z
    .string()
    .min(1)
    .optional()
    .describe(
      'Directory to search in. If not specified, searches in current working directory.',
    ),
  textPattern: z
    .string()
    .min(1)
    .describe(
      'Text or regex pattern to search for in file contents (regex supported by ripgrep)',
    ),
  filePath: z
    .string()
    .optional()
    .describe(
      'Search only in this specific file. Can use paths from files_find_paths output.',
    ),
  onlyInFilesMatching: z
    .array(z.string())
    .optional()
    .describe(
      'Only search files matching these glob patterns (e.g., ["*.ts", "src/**"])',
    ),
  skipFilesMatching: z
    .array(z.string())
    .optional()
    .describe(
      'Don\'t search files matching these glob patterns (e.g., ["*.test.ts", "node_modules/**"])',
    ),
});

export type FilesSearchTextToolSchemaType = z.infer<
  typeof FilesSearchTextToolSchema
>;

type FilesSearchTextToolOutput = {
  error?: string;
  matches?: {
    type: string;
    data: {
      path?: {
        text: string;
      };
      lines?: {
        text: string;
      };
      line_number?: number;
      absolute_offset?: number;
      submatches?: {
        match: {
          text: string;
        };
        start: number;
        end: number;
      }[];
    };
  }[];
};

function shQuote(s: string) {
  return `'${s.replace(/'/g, `'\\''`)}'`;
}

@Injectable()
export class FilesSearchTextTool extends FilesBaseTool<FilesSearchTextToolSchemaType> {
  public name = 'files_search_text';
  public description =
    'Search file contents with ripgrep (regex) and return structured matches.';

  protected override generateTitle(
    args: FilesSearchTextToolSchemaType,
    _config: FilesBaseToolConfig,
  ): string {
    const location = args.filePath
      ? basename(args.filePath)
      : (args.searchInDirectory ?? 'current directory');
    return `Searching for "${args.textPattern}" in ${location}`;
  }

  public getDetailedInstructions(
    _config: FilesBaseToolConfig,
    _lgConfig?: ExtendedLangGraphRunnableConfig,
  ): string {
    return dedent`
      ### Overview
      Searches text patterns across files using ripgrep. Returns JSON with file paths, line numbers, matches. If \`searchInDirectory\` omitted, searches in current shell cwd. Supports regex.

      ### When to Use
      Finding function/class/variable definitions or usages, specific patterns (TODO, errors), config values, imports, feature implementations.

      ### When NOT to Use
      When exact file known → use files_read. For listing files → use files_find_paths. For symbol search → use files_search_tags if available.

      ### Best Practices
      Be specific with patterns. Prefer a single search with regex alternation (e.g., "class|docs|other") and minimal glob filters instead of multiple tool calls. Use file filters (onlyInFilesMatching/skipFilesMatching) to reduce noise. Escape special regex chars. For type/enum discovery: search "(enum|type|interface)\\\\s+TypeName" first, then field definitions if not found.

      ### Default excludes
      Auto-excludes (when skipFilesMatching NOT provided): .git, node_modules, dist, build, coverage, .next, .turbo, .vercel, .cache, out, .output, tmp, temp, src/autogenerated. If you provide skipFilesMatching, defaults NOT applied (include them explicitly if needed, plus repo-specific like generated/, vendor/, target/).

      ### Examples
      **1. Literal search:**
      \`\`\`json
      {"searchInDirectory": "/repo", "textPattern": "getUserById"}
      \`\`\`

      **2. Regex search for function definitions:**
      \`\`\`json
      {"searchInDirectory": "/repo", "textPattern": "function\\\\s+handleSubmit|const\\\\s+handleSubmit"}
      \`\`\`

      **3. Case-insensitive search:**
      \`\`\`json
      {"textPattern": "(?i)error", "onlyInFilesMatching": ["*.ts"]}
      \`\`\`

      **4. Find React hooks in specific files:**
      \`\`\`json
      {"searchInDirectory": "/repo/src", "textPattern": "use(State|Effect|Ref)\\\\(", "onlyInFilesMatching": ["*.tsx"], "skipFilesMatching": ["*.test.tsx"]}
      \`\`\`

      **5. Find type/enum definitions:**
      \`\`\`json
      {"textPattern": "(enum|type|interface)\\\\s+UserRole"}
      \`\`\`

      ### Results
      Returns up to 30 matches. Empty array if no matches. Use files_read with line ranges to see context around matches.
    `;
  }

  public get schema() {
    return zodToAjvSchema(FilesSearchTextToolSchema);
  }

  public async invoke(
    args: FilesSearchTextToolSchemaType,
    config: FilesBaseToolConfig,
    cfg: ToolRunnableConfig<BaseAgentConfigurable>,
  ): Promise<ToolInvokeResult<FilesSearchTextToolOutput>> {
    const title = this.generateTitle?.(args, config);
    const messageMetadata = { __title: title };
    const cmdParts: string[] = ['rg', '--json'];

    if (args.filePath) {
      cmdParts.push('--', shQuote(args.textPattern), shQuote(args.filePath));
    } else {
      cmdParts.push('--hidden');

      const defaultExcludes = [
        '.git',
        'node_modules',
        '.next',
        'dist',
        'build',
        'coverage',
        '.turbo',
        '.vercel',
        '.cache',
        'out',
        '.output',
        'tmp',
        'temp',
        'src/autogenerated',
      ];

      if (args.onlyInFilesMatching && args.onlyInFilesMatching.length > 0) {
        for (const glob of args.onlyInFilesMatching) {
          cmdParts.push('--glob', shQuote(glob));
        }
      }

      if (args.skipFilesMatching && args.skipFilesMatching.length > 0) {
        for (const glob of args.skipFilesMatching) {
          cmdParts.push('--glob', shQuote(`!${glob}`));
        }
      } else {
        for (const glob of defaultExcludes) {
          cmdParts.push('--glob', shQuote(`!${glob}/**`));
        }
      }

      cmdParts.push('--', shQuote(args.textPattern), '.');
    }

    const baseCmd = cmdParts.join(' ');
    const cmd = args.searchInDirectory
      ? `cd ${shQuote(args.searchInDirectory)} && ${baseCmd}`
      : baseCmd;

    const res = await this.execCommand(
      {
        cmd,
      },
      config,
      cfg,
    );

    if (res.exitCode !== 0) {
      if (res.exitCode === 1 && !res.stderr) {
        return {
          output: {
            matches: [],
          },
          messageMetadata,
        };
      }

      return {
        output: {
          error: res.stderr || res.stdout || 'Failed to search text',
        },
        messageMetadata,
      };
    }

    const lines = res.stdout
      .split('\n')
      .filter((line) => line.trim().length > 0);
    const matches: FilesSearchTextToolOutput['matches'] = [];
    type Match = NonNullable<FilesSearchTextToolOutput['matches']>[number];

    for (const line of lines) {
      try {
        const parsed = JSON.parse(line) as unknown;
        const parsedType = isObject(parsed)
          ? (parsed as { type?: unknown }).type
          : undefined;

        if (parsedType === 'match') {
          if (matches.length >= MAX_MATCHES) {
            break;
          }
          matches.push(parsed as Match);
        }
      } catch {
        continue;
      }
    }

    return {
      output: {
        matches,
      },
      messageMetadata,
    };
  }
}
